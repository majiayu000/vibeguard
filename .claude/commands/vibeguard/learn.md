---
name: "VibeGuard: Learn"
description: "双模式学习：(A) 从错误中提取守卫规则 (B) 从发现中提取可复用 Skill。自动模式路由。"
category: VibeGuard
tags: [vibeguard, learn, feedback, improvement, skill-extraction]
argument-hint: "<错误描述 | 'extract' 提取经验 | 空=自动判断>"
---

<!-- VIBEGUARD:LEARN:START -->

## 核心理念

- Agent 犯错不是终点，是改进防御体系的信号
- Agent 发现非显而易见的解决方案时，应提取为可复用知识
- 目标：**错误不再重犯 + 经验不再遗忘**

## 模式路由

根据参数和上下文自动选择模式：

| 输入 | 模式 |
|------|------|
| 用户描述了错误/bug/守卫失效 | **模式 A**：错误分析 → 产出 guard/hook/rule |
| 用户说 "extract" / "提取经验" / "学到了什么" | **模式 B**：经验提取 → 产出 SKILL.md |
| Stop hook 自动触发（无参数） | 先评估 → 按需选择 A 或 B |
| 会话中同时有错误修复和非显而易见的发现 | **A + B 都执行** |

---

## 模式 A：错误分析（防御向）

> 从错误中学习，生成守卫规则或 hook，让同类错误不再发生。

**触发场景**
- Agent 创建了重复文件/类型（L1 失效）
- Agent 硬编码了路径/端口/URL（L4 失效）
- Agent 引入了数据分裂（多入口不一致）
- Agent 做了不必要的过度设计（L5 失效）
- 守卫脚本存在假阳性或假阴性
- 任何重复出现的 Agent 错误模式

**Guardrails**
- 不直接修复业务代码 — 只改进 VibeGuard 本身
- 新规则必须可验证（能写脚本检测或测试断言）
- 不做过度泛化 — 一个错误模式对应一条精确规则

**Steps**

1. **自动模式识别（从 events.jsonl 提取）**
   - 读取 `~/.vibeguard/events.jsonl`，分析最近的事件记录
   - 提取高频 warn 模式：被多次警告但仍重复发生的同类问题
   - 提取反复被 block 的同类操作：识别 agent 反复碰壁的操作模式
   - 按 hook + reason 分组，输出 top 5 高频问题
   - 将识别到的模式作为后续分析的输入（不再完全依赖用户描述）

2. **收集错误上下文**
   - 用户描述了什么错误？（参数 `$ARGUMENTS` 或对话上下文）
   - 结合步骤 1 的自动识别结果，确认是否为已知的高频问题
   - 错误发生在哪个文件/模块？
   - 错误的具体表现（diff、截图、报错信息）
   - 这是第几次出现类似错误？

3. **根因分析（5-Why）**
   - **表面原因**：Agent 做了什么错误操作？
   - **直接原因**：为什么现有守卫没拦住？
     - 守卫脚本不存在？→ 需要新守卫
     - 守卫存在但模式匹配不够？→ 增强守卫
     - Hook 没覆盖该操作？→ 新增 hook 规则
     - 规则文件没提到？→ 补充规则
   - **根本原因**：系统层面缺了什么？
     - 缺少文档/地图？
     - 缺少机械化检查？
     - 约束不够具体？

4. **确定改进类型**

   | 改进类型 | 适用场景 | 产出 |
   |----------|----------|------|
   | 新守卫脚本 | 需要新的代码模式检测 | `guards/<lang>/check_xxx.sh` |
   | 增强现有守卫 | 现有守卫漏检 | 修改 `guards/` 下的脚本 |
   | 新 hook 规则 | 需要在操作前/后拦截 | 修改 `hooks/` 下的脚本 |
   | 新规则条目 | 需要补充判断标准 | 修改 `rules/` 下的规则文件 |
   | 新约束到 CLAUDE.md | 需要全局生效的约束 | 修改 `vibeguard-rules.md` |

5. **[Stop] 确认改进方案**
   - 展示即将写入的新规则/hook 内容
   - 用 AskUserQuestion 让用户确认再继续
   - 防止自动生成的规则有误

6. **实施改进**

   **新守卫脚本**：
   - 参考 `guards/rust/check_unwrap_in_prod.sh` 的模板
   - 必须包含：`--strict` 模式、`set -euo pipefail`、排除 tests/
   - 输出格式：`[ID] 问题描述` + 修复方法（remediation）
   - 注册到 `/vibeguard:check` 命令

   **增强现有守卫**：
   - 先运行现有守卫确认假阴性
   - 增加新的检测模式
   - 确保不破坏现有检测

   **新 hook 规则**：
   - PreToolUse hook 用于阻止操作（block）
   - PostToolUse hook 用于事后警告（warn）
   - 每个 block 消息必须包含替代方案
   - 注册到 `setup.sh`

   **新规则条目**：
   - 分配新 ID（RS-XX / U-XX）
   - 包含：类别、检查项、严重度、修复模式
   - 添加到 FIX/SKIP 判断矩阵

7. **模式识别与规则生成**

   **错误模式分类**
   | 模式 | 特征 | 生成规则类型 |
   |------|------|-------------|
   | 重复创建 | 同一功能多次新建文件 | 守卫脚本（检测相似文件名/函数名） |
   | 路径幻觉 | 编辑/引用不存在的文件 | Hook 规则（pre-edit 检查文件存在） |
   | API 幻觉 | 调用不存在的方法/字段 | 规则条目（标注真实 API 列表） |
   | 过度设计 | 添加不需要的抽象层 | 约束条目（最小改动原则强化） |
   | 数据分裂 | 多入口硬编码不同路径 | 守卫脚本（跨入口路径一致性检查） |
   | 命名混乱 | 同一概念多个名字 | 命名规范条目 + 别名检测 |

   **规则模板生成**
   - 从错误实例中提取检测模式（正则/AST/文件结构）
   - 生成守卫脚本草稿，包含：检测逻辑、排除条件、修复建议
   - 输出到 `guards/<lang>/` 或 `hooks/` 目录

8. **验证改进**
   - 用原始错误场景验证新守卫/hook 能检测到问题
   - 运行现有所有守卫确认无回归
   - 更新守卫 ID 索引（`vibeguard-rules.md`）

9. **输出学习报告**

   ```markdown
   # VibeGuard Learn Report (Mode A)

   ## 错误描述
   <简述错误>

   ## 根因分析
   - 表面原因：...
   - 直接原因：...
   - 根本原因：...

   ## 改进内容
   - [ ] <改进类型>：<具体描述>

   ## 验证结果
   - 新守卫检测通过：✓/✗
   - 现有守卫无回归：✓/✗

   ## 防御体系变化
   - 守卫数量：N → N+1
   - Hook 规则数：M → M+1
   - 规则条目数：K → K+1
   ```

---

## 模式 B：经验提取（积累向）

> 从非显而易见的发现中提取可复用知识，保存为 Skill 文件，让未来遇到类似问题时自动调用。
> 灵感来源：Claudeception（Voyager skill library + Reflexion self-reflection）

**触发场景**
- 调试花了 >10 分钟，解决方案在文档中找不到
- 错误消息有误导性，实际根因与表象不同
- 通过试错发现了工具/框架的限制和绕过方法
- 发现了项目特有的配置/架构模式
- 多次尝试后才找到有效方案

**质量门控（4 条必须全部满足）**

| 标准 | 定义 | 反例 |
|------|------|------|
| **可复用** | 未来类似任务能用上 | "这个变量名打错了" |
| **非平凡** | 需要探索才能发现，不是查文档就行 | "npm install 安装依赖" |
| **具体** | 能描述精确的触发条件和解决步骤 | "React 有时候会报错" |
| **已验证** | 方案实际测试过，不是理论推测 | "应该可以用 XX 解决" |

**Steps**

1. **自我评估**

   回答以下问题（任一为"是"则继续）：
   - 刚才是否涉及非显而易见的调试/排查？
   - 解决方案是否可复用于未来类似场景？
   - 是否发现了文档未覆盖的知识？
   - 错误消息是否有误导性？
   - 是否通过试错才找到方案？

   全部为"否" → 跳过，不提取。

2. **去重检查**

   在提取前搜索已有 Skill：

   ```bash
   # 搜索路径（优先项目级，再用户级）
   SKILL_DIRS=(".claude/skills" "$HOME/.claude/skills")

   # 按关键词搜索
   rg -i "keyword1|keyword2" "${SKILL_DIRS[@]}" 2>/dev/null

   # 按错误消息搜索
   rg -F "exact error message" "${SKILL_DIRS[@]}" 2>/dev/null
   ```

   **去重决策表**

   | 搜索结果 | 动作 |
   |----------|------|
   | 无相关 | 新建 Skill |
   | 相同触发 + 相同方案 | 更新已有（version +minor） |
   | 相同触发 + 不同根因 | 新建，双向添加 `See also:` |
   | 相同领域 + 不同触发 | 更新已有，加 "变体" 小节 |
   | 已有但过时/错误 | 标记废弃，新建替代 |

3. **提取知识**

   分析本次发现：
   - 问题是什么？
   - 解决方案中哪部分是非显而易见的？
   - 下次遇到需要知道什么才能更快解决？
   - 触发条件是什么（错误消息、症状、场景）？

4. **条件性 Web 研究**

   以下情况需要搜索验证：
   - 涉及特定技术/框架的最佳实践
   - 可能在 2025 年后有变化的 API/工具
   - 不确定当前方案是否为推荐做法

   搜索策略：
   - 官方文档：`"[技术] [功能] official docs 2026"`
   - 最佳实践：`"[技术] [问题] best practices 2026"`
   - 常见问题：`"[技术] [错误消息] solution 2026"`

   项目内部模式、明确的上下文特定方案、稳定的通用编程概念 → 跳过搜索。

5. **结构化为 SKILL.md**

   ```markdown
   ---
   name: descriptive-kebab-case-name
   description: |
     [精确描述，包含：(1) 解决什么问题 (2) 触发条件（错误消息/症状）
     (3) 涉及的技术/框架。用 "Use when:" 开头列举使用场景]
   author: Claude Code
   version: 1.0.0
   date: YYYY-MM-DD
   ---

   # [Skill 名称]

   ## Problem
   [问题描述：什么痛点？为什么非显而易见？]

   ## Context / Trigger Conditions
   - [精确的错误消息]
   - [可观察的症状/行为]
   - [环境条件（框架/工具/平台）]

   ## Solution
   ### Step 1: ...
   ### Step 2: ...
   ### Step 3: ...

   ## Verification
   [如何确认方案有效]

   ## Example
   **场景**：[具体案例]
   **Before**：[错误状态]
   **After**：[修复后状态]

   ## Notes
   - [注意事项、边界情况]
   - [何时不应使用此 Skill]
   - [See also: 相关 Skill]

   ## References
   - [来源链接（如有 Web 研究）]
   ```

6. **保存位置决策**

   | 类型 | 位置 | 说明 |
   |------|------|------|
   | 项目特定 | `.claude/skills/[name]/SKILL.md` | 仅对当前项目有用 |
   | 跨项目通用 | `~/.claude/skills/[name]/SKILL.md` | 未来所有项目可用 |

7. **[Stop] 确认并保存**
   - 展示生成的 SKILL.md 内容
   - 用 AskUserQuestion 让用户确认
   - 确认后写入文件

8. **输出提取报告**

   ```markdown
   # VibeGuard Learn Report (Mode B)

   ## 发现描述
   <本次非显而易见的发现>

   ## 提取的 Skill
   - 名称：[skill-name]
   - 位置：[文件路径]
   - 版本：1.0.0

   ## 质量检查
   - 可复用：✓
   - 非平凡：✓
   - 具体：✓
   - 已验证：✓
   - 无重复：✓
   - 无敏感信息：✓

   ## Skill 生命周期
   创建 → 迭代（发现新场景时 version +minor）→ 废弃（底层变化时标记）→ 归档
   ```

---

## 反模式

| 反模式 | 说明 |
|--------|------|
| **过度提取** | 不是每个任务都值得提取，平凡的操作不需要 Skill |
| **描述模糊** | "帮助解决数据库问题" 不会被语义匹配命中 |
| **未验证方案** | 只提取实际测试过的方案，不提取理论推测 |
| **重复文档** | 不要重写官方文档，链接到它然后补充缺失部分 |
| **过期知识** | Skill 必须带版本和日期，过期时标记废弃 |
| **泄露敏感信息** | Skill 中禁止包含密钥、内部 URL、API key |

## 设计原则

- **精确优先**：一条规则解决一类问题，不做笼统的"注意代码质量"
- **机械化优先**：能写脚本检测的就写脚本，不依赖 agent 自觉遵守
- **错误消息即修复指令**：守卫输出要告诉 agent HOW to fix，不只是 WHAT is wrong
- **最小改动**：不要因为一个边缘 case 重写整个守卫体系
- **描述即检索**：Skill 的 description 直接决定能否被语义匹配命中

## Reference

- VibeGuard 守卫脚本模板：`vibeguard/guards/`
- Hook 脚本模板：`vibeguard/hooks/`
- 规则文件：`vibeguard/rules/`
- 规则索引：`vibeguard/claude-md/vibeguard-rules.md`
- Skill 模板：`vibeguard/resources/skill-template.md`
- 学术参考：Voyager (skill libraries), CASCADE (meta-skills), Reflexion (self-reflection)
<!-- VIBEGUARD:LEARN:END -->
